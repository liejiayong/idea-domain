<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>正则表达式总结 | chovitaminljy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <meta name="description" content="正则表达式是匹配模式，要么匹配字符，要么匹配位置  字符匹配内容包括： 1.两种模糊匹配 2.字符组 3.量词 4.分支结构 5.案例分析 1 两种模糊匹配 1.1 横向模糊匹配  一个正则可匹配的字符串的长度不是固定的，可以是多种情况的var regex = /ab{2,5}c/gvar string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;con">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式总结">
<meta property="og:url" content="http://https://liejiayong.github.io/chovitaminljy/2018/04/05/regular Expression/index.html">
<meta property="og:site_name" content="chovitaminljy">
<meta property="og:description" content="正则表达式是匹配模式，要么匹配字符，要么匹配位置  字符匹配内容包括： 1.两种模糊匹配 2.字符组 3.量词 4.分支结构 5.案例分析 1 两种模糊匹配 1.1 横向模糊匹配  一个正则可匹配的字符串的长度不是固定的，可以是多种情况的var regex = /ab{2,5}c/gvar string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;con">
<meta property="og:locale" content="zh-cms-Hans">
<meta property="og:updated_time" content="2018-06-28T15:29:37.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式总结">
<meta name="twitter:description" content="正则表达式是匹配模式，要么匹配字符，要么匹配位置  字符匹配内容包括： 1.两种模糊匹配 2.字符组 3.量词 4.分支结构 5.案例分析 1 两种模糊匹配 1.1 横向模糊匹配  一个正则可匹配的字符串的长度不是固定的，可以是多种情况的var regex = /ab{2,5}c/gvar string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;con">
  
    <link rel="alternate" href="/atom.xml" title="chovitaminljy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">chovitaminljy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://https://liejiayong.github.io/chovitaminljy"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-regular Expression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/regular Expression/" class="article-date">
  <time datetime="2018-04-05T13:38:13.641Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        <h1 class="article-title" itemprop="name">
      正则表达式总结
    </h1>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置</p>
</blockquote>
<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><pre><code>内容包括：
1.两种模糊匹配
2.字符组
3.量词
4.分支结构
5.案例分析
</code></pre><p>1 两种模糊匹配</p>
<p>1.1 横向模糊匹配</p>
<blockquote>
<p>一个正则可匹配的字符串的长度不是固定的，可以是多种情况的<br>var regex = /ab{2,5}c/g<br>var string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;<br>console.log( string.match(regex) );<br>// =&gt; [“abbc”, “abbbc”, “abbbbc”, “abbbbbc”]</p>
</blockquote>
<p>1.2 纵向模糊匹配</p>
<blockquote>
<p>一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p>
</blockquote>
<hr>
<p>var regex = /a[123]b/g;<br>var string = “a0b a1b a2b a3b a4b”;<br>console.log( string.match(regex) );</p>
<h2 id="gt-“a1b”-“a2b”-“a3b”"><a href="#gt-“a1b”-“a2b”-“a3b”" class="headerlink" title="// =&gt; [“a1b”, “a2b”, “a3b”]"></a>// =&gt; [“a1b”, “a2b”, “a3b”]</h2><ol start="2">
<li>字符组 []<br>2.1 范围表示法<br>匹配“a”、“-”、“z”这三者中任意一个字符<br>[-az]或[az-]或[a-z]</li>
</ol>
<p>2.2 排除字符组<br>字符组的第一位放^（脱字符），表示求反的概念<br>[^abc]，表示是一个除”a”、”b”、”c”之外的任意一个字符</p>
<p>2.3 常见的简写形式<br>    \d   就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。<br>    \D   就是[^0-9]。表示除数字外的任意字符。<br>    \w   就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。<br>    \W   是[^0-9a-zA-Z_]。非单词字符。<br>    \s   是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。<br>    \S  是[^ \t\v\n\r\f]。 非空白符。<br>    .    就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。</p>
<h1 id="字符组总结："><a href="#字符组总结：" class="headerlink" title="字符组总结："></a>字符组总结：</h1><pre><code>[\d\D]、[\w\W]、[\s\S]和[^]都可以实现匹配任意字符
</code></pre><ol start="3">
<li>量词</li>
</ol>
<p>量词也称重复。掌握{m,n}的准确含义后，只需要记住一些简写形式。</p>
<p>3.1 简写形式<br>    {m,}     表示至少出现m次。<br>    {m}      等价于{m,m}，表示出现m次。<br>    ?        等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</p>
<pre><code>+        等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
*        等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
</code></pre><p>3.2 贪婪匹配和惰性匹配<br>    例子：</p>
<pre><code>贪婪-&gt;它会尽可能多的匹配 (只要在能力范围内，越多越好)
</code></pre><hr>
<pre><code>var regex = /\d{2,5}/g;
var string = &quot;123 1234 12345 123456&quot;;
console.log( string.match(regex) );
// =&gt; [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;]
</code></pre><hr>
<pre><code>惰性-&gt;尽可能少的匹配
</code></pre><hr>
<pre><code>var regex = /\d{2,5}?/g;
var string = &quot;123 1234 12345 123456&quot;;
console.log( string.match(regex) );
// =&gt; [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;]
</code></pre><hr>
<pre><code>惰性匹配总结：
    1.通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：
    {m,n}?
    {m,}?
    ??
    +?
    *?

    2.对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？
    3.分支也属于惰性
</code></pre><ol start="4">
<li><p>多选分支</p>
<blockquote>
<p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。<br> 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一</p>
</blockquote>
<p>  例如要匹配”good”和”nice”可以使用/good|nice/。测试如下：</p>
</li>
</ol>
<hr>
<pre><code>var regex = /good|nice/g;
var string = &quot;good idea, nice try.&quot;;
console.log( string.match(regex) );
// =&gt; [&quot;good&quot;, &quot;nice&quot;]
</code></pre><hr>
<pre><code>但有个事实我们应该注意，比如我用/good|goodbye/，去匹配&quot;goodbye&quot;字符串时，结果是&quot;good&quot;：
</code></pre><hr>
<pre><code>var regex = /good|goodbye/g;
var string = &quot;goodbye&quot;;
console.log( string.match(regex) );
// =&gt; [&quot;good&quot;]
</code></pre><hr>
<pre><code>而把正则改成/goodbye|good/，结果是：
</code></pre><hr>
<pre><code>var regex = /goodbye|good/g;
var string = &quot;goodbye&quot;;
console.log( string.match(regex) );
// =&gt; [&quot;goodbye&quot;]
</code></pre><hr>
<p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。<br>下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）：</p>
<ol start="5">
<li>案例分析<blockquote>
<p>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。</p>
</blockquote>
</li>
</ol>
<p>5.1 匹配16进制颜色值<br>要求匹配：</p>
<p>#ffbbad</p>
<p>#Fc01DF</p>
<p>#FFF</p>
<h2 id="ffE"><a href="#ffE" class="headerlink" title="#ffE"></a>#ffE</h2><p>var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;<br>var string = “#ffbbad #Fc01DF #FFF #ffE”;<br>console.log( string.match(regex) );</p>
<h2 id="gt-“-ffbbad”-“-Fc01DF”-“-FFF”-“-ffE”"><a href="#gt-“-ffbbad”-“-Fc01DF”-“-FFF”-“-ffE”" class="headerlink" title="// =&gt; [“#ffbbad”, “#Fc01DF”, “#FFF”, “#ffE”]"></a>// =&gt; [“#ffbbad”, “#Fc01DF”, “#FFF”, “#ffE”]</h2><p>5.2 匹配时间<br>以24小时制为例。<br>要求匹配：<br>23:59</p>
<h2 id="02-07"><a href="#02-07" class="headerlink" title="02:07"></a>02:07</h2><p>var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;<br>console.log( regex.test(“23:59”) );<br>console.log( regex.test(“02:07”) );<br>// =&gt; true</p>
<h2 id="gt-true"><a href="#gt-true" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.3 匹配日期<br>比如yyyy-mm-dd格式为例。<br>要求匹配：</p>
<h2 id="2017-10-13"><a href="#2017-10-13" class="headerlink" title="2017-10-13"></a>2017-10-13</h2><p>var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;<br>console.log( regex.test(“2017-06-10”) );</p>
<h2 id="gt-true-1"><a href="#gt-true-1" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.4 window操作系统文件路径<br>要求匹配：<br>F:\study\javascript\regex\regular expression.pdf<br>F:\study\javascript\regex\<br>F:\study\javascript</p>
<h2 id="F"><a href="#F" class="headerlink" title="F:\"></a>F:\</h2><p>var regex = /^[a-zA-Z]:\([^\&lt;&gt;|’’?\r\n/]+\)*([^\&lt;&gt;|’’?\r\n/]+)?$/;<br>console.log( regex.test(“F:\study\javascript\regex\regular expression.pdf”) );<br>console.log( regex.test(“F:\study\javascript\regex\“) );<br>console.log( regex.test(“F:\study\javascript”) );<br>console.log( regex.test(“F:\“) );<br>// =&gt; true<br>// =&gt; true<br>// =&gt; true</p>
<h2 id="gt-true-2"><a href="#gt-true-2" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.5 匹配id<br>要求从</p>
<p><div id="container" class="main"></div></p>
<h2 id="提取出id-”container”"><a href="#提取出id-”container”" class="headerlink" title="提取出id=”container”"></a>提取出id=”container”</h2><p>var regex = /id=”[^”]”/;</p>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><blockquote>
<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p>
</blockquote>
<pre><code>内容包括：
1.什么是位置？
2.如何匹配位置？
3.位置的特性
4.几个应用实例分析
</code></pre><ol>
<li><p>什么是位置呢？<br>位置是相邻字符之间的位置.<br>如：HELLO<br>||||||    这里的一杠所致向的是相邻字符之间的位置.</p>
</li>
<li><p>如何匹配位置呢？</p>
<p> 在ES5中，共有6个锚字符：<br> ^ $ \b \B (?=p) (?!p)</p>
</li>
</ol>
<p>2.1 ^和$<br>    ^（脱字符）匹配开头，在多行匹配中匹配行开头。<br>    $（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p>
<h2 id="比如我们把字符串的开头和结尾用”-”替换（位置可以替换成字符的！）"><a href="#比如我们把字符串的开头和结尾用”-”替换（位置可以替换成字符的！）" class="headerlink" title="比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）"></a>比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）</h2><p>var regex = \^|$\g<br>var result = “hello”.replace(regex,”#”);<br>console.log(result);</p>
<h2 id="gt-“-hello-”"><a href="#gt-“-hello-”" class="headerlink" title="// =&gt; “#hello#”"></a>// =&gt; “#hello#”</h2><h2 id="多行匹配模式时，二者是行的概念，这个需要我们的注意："><a href="#多行匹配模式时，二者是行的概念，这个需要我们的注意：" class="headerlink" title="多行匹配模式时，二者是行的概念，这个需要我们的注意："></a>多行匹配模式时，二者是行的概念，这个需要我们的注意：</h2><p>var result = “I\nlove\njavascript”.replace(/^|$/gm, ‘#’);<br>console.log(result);<br>/*</p>
<p>#I#</p>
<p>#love#</p>
<p>#javascript#</p>
<h2 id=""><a href="#" class="headerlink" title="*/"></a>*/</h2><p>2.2 \b和\B<br>    \b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。</p>
<pre><code>比如一个文件名是&quot;[JS] Lesson_01.mp4&quot;中的\b，如下：
</code></pre><hr>
<p>var result = “[JS] Lesson_01.mp4”.replace(/\b/g, ‘#’);<br>console.log(result);</p>
<h2 id="gt-“-JS-Lesson-01-mp4-”"><a href="#gt-“-JS-Lesson-01-mp4-”" class="headerlink" title="// =&gt; “[#JS#] #Lesson_01#.#mp4#”"></a>// =&gt; “[#JS#] #Lesson_01#.#mp4#”</h2><pre><code>\B就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。

比如上面的例子，把所有\B替换成&quot;#&quot;：
</code></pre><hr>
<p>var result = “[JS] Lesson_01.mp4”.replace(/\B/g, ‘#’);<br>console.log(result);</p>
<h2 id="gt-“-J-S-L-e-s-s-o-n-0-1-m-p-4”"><a href="#gt-“-J-S-L-e-s-s-o-n-0-1-m-p-4”" class="headerlink" title="// =&gt; “#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4”"></a>// =&gt; “#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4”</h2><pre><code>\b和\B总结：
\b -&gt; 不连续单词边界
\B -&gt;
</code></pre><p>2.3 (?=p)和(?!p)<br>    (?=p)，其中p是一个子模式，即p前面的位置。</p>
<h2 id="比如-l-，表示’l’字符前面的位置，例如："><a href="#比如-l-，表示’l’字符前面的位置，例如：" class="headerlink" title="比如(?=l)，表示’l’字符前面的位置，例如："></a>比如(?=l)，表示’l’字符前面的位置，例如：</h2><p>var result = “hello”.replace(/(?=l)/g, ‘#’);<br>console.log(result);</p>
<h2 id="gt-“he-l-lo”"><a href="#gt-“he-l-lo”" class="headerlink" title="// =&gt; “he#l#lo”"></a>// =&gt; “he#l#lo”</h2><h2 id="而-p-就是-p-的反面意思，比如："><a href="#而-p-就是-p-的反面意思，比如：" class="headerlink" title="而(?!p)就是(?=p)的反面意思，比如："></a>而(?!p)就是(?=p)的反面意思，比如：</h2><p>var result = “hello”.replace(/(?!l)/g, ‘#’);<br>console.log(result);</p>
<h2 id="gt-“-h-ell-o-”"><a href="#gt-“-h-ell-o-”" class="headerlink" title="// =&gt; “#h#ell#o#”"></a>// =&gt; “#h#ell#o#”</h2><pre><code>(?=p)和(?!p)总结：
-----------------------------------------------------------
|     分类依据     |      (?=p)         |    (?!p)
-----------------------------------------------------------
|     学名         | positive lookahead | negative lookahead
-----------------------------------------------------------
|     中文翻译     |  正向先行断言      |  负向先行断言
-----------------------------------------------------------
|     环视         |  看看右边          |  看看左边
-----------------------------------------------------------
|     (?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符
|     而在本人看来(?=p)就与^一样好理解，就是p前面的那个位置
-----------------------------------------------------------
</code></pre><ol start="3">
<li><p>位置的特性</p>
<blockquote>
<p>对于位置的理解，我们可以理解成空字符””</p>
</blockquote>
<p> 比如”hello”字符串等价于如下的形式：<br> “hello” == “” + “h” + “” + “e” + “” + “l” + “” + “l” + “o” + “”;<br> 也等价于：<br> “hello” == “” + “” + “hello”</p>
</li>
</ol>
<h2 id="因此，把-hello-写成-hello-，是没有任何问题的："><a href="#因此，把-hello-写成-hello-，是没有任何问题的：" class="headerlink" title="因此，把/^hello$/写成/^^hello$$$/，是没有任何问题的："></a>因此，把/^hello$/写成/^^hello$$$/，是没有任何问题的：</h2><p>var result = /^^hello$$$/.test(“hello”);<br>console.log(result);</p>
<h2 id="gt-true-3"><a href="#gt-true-3" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><h2 id="甚至可以写成更复杂的"><a href="#甚至可以写成更复杂的" class="headerlink" title="甚至可以写成更复杂的:"></a>甚至可以写成更复杂的:</h2><p>var result = /(?=he)^^he(?=\w)llo$\b\b$/.test(“hello”);<br>console.log(result);</p>
<h2 id="gt-true-4"><a href="#gt-true-4" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><ol start="4">
<li>相关案例</li>
</ol>
<h2 id="4-1-不匹配任何东西的正则"><a href="#4-1-不匹配任何东西的正则" class="headerlink" title="4.1 不匹配任何东西的正则"></a>4.1 不匹配任何东西的正则</h2><p>.^\</p>
<h2 id="因为此正则要求只有一个字符，但该字符后面是开头。"><a href="#因为此正则要求只有一个字符，但该字符后面是开头。" class="headerlink" title="因为此正则要求只有一个字符，但该字符后面是开头。"></a>因为此正则要求只有一个字符，但该字符后面是开头。</h2><p>4.2 数字的千位分隔符表示法<br>比如把”12345678”，变成”12,345,678”。<br>可见是需要把相应的位置替换成”,”。</p>
<h2 id="4-2-1-弄出最后一个逗号"><a href="#4-2-1-弄出最后一个逗号" class="headerlink" title="4.2.1 弄出最后一个逗号"></a>4.2.1 弄出最后一个逗号</h2><p>var result = “12345678”.replace(/(?=\d{3}$)/g, ‘,’)<br>console.log(result);</p>
<h2 id="gt-“12345-678”"><a href="#gt-“12345-678”" class="headerlink" title="// =&gt; “12345,678”"></a>// =&gt; “12345,678”</h2><h2 id="4-2-2-弄出所有的逗号"><a href="#4-2-2-弄出所有的逗号" class="headerlink" title="4.2.2 弄出所有的逗号"></a>4.2.2 弄出所有的逗号</h2><p>var result = “123456789”.replace(/(?=(\d{3})+$)/g, ‘,’)<br>console.log(result);</p>
<h2 id="gt-“-123-456-789”"><a href="#gt-“-123-456-789”" class="headerlink" title="// =&gt; “,123,456,789”"></a>// =&gt; “,123,456,789”</h2><p>因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。<br>怎么解决呢？我们要求匹配的到这个位置不能是开头。<br>我们知道匹配开头可以使用^，但要求这个位置不是开头怎么办？</p>
<hr>
<p>var string1 = “12345678”,<br>string2 = “123456789”;<br>var reg = /(?!^)(?=(\d{3})+$)/g;</p>
<p>var result = string1.replace(reg, ‘,’)<br>console.log(result);<br>// =&gt; “12,345,678”</p>
<p>result = string2.replace(reg, ‘,’);<br>console.log(result);</p>
<h2 id="gt-“123-456-789”"><a href="#gt-“123-456-789”" class="headerlink" title="// =&gt; “123,456,789”"></a>// =&gt; “123,456,789”</h2><p>4.2.4 支持其他形式<br>如果要把”12345678 123456789”替换成”12,345,678 123,456,789”。</p>
<h2 id="此时我们需要修改正则，把里面的开头-和结尾-，替换成-b："><a href="#此时我们需要修改正则，把里面的开头-和结尾-，替换成-b：" class="headerlink" title="此时我们需要修改正则，把里面的开头^和结尾$，替换成\b："></a>此时我们需要修改正则，把里面的开头^和结尾$，替换成\b：</h2><p>var string = “12345678 123456789”,<br>reg = /(?!\b)(?=(\d{3})+\b)/g;    或/\B(?=(\d{3})+\b)/g<br>var result = string.replace(reg, ‘,’)<br>console.log(result);</p>
<h2 id="gt-“12-345-678-123-456-789”"><a href="#gt-“12-345-678-123-456-789”" class="headerlink" title="// =&gt; “12,345,678 123,456,789”"></a>// =&gt; “12,345,678 123,456,789”</h2><p>4.3 验证密码问题<br>1.同时包含数字和小写字母<br>2.同时包含数字和大写字母<br>3.同时包含小写字母和大写字母<br>4.同时包含数字、小写字母和大写字母</p>
<h2 id="以上的4种情况是或的关系（实际上，可以不用第4条）。"><a href="#以上的4种情况是或的关系（实际上，可以不用第4条）。" class="headerlink" title="以上的4种情况是或的关系（实际上，可以不用第4条）。"></a>以上的4种情况是或的关系（实际上，可以不用第4条）。</h2><p>var reg = /((?=.<em>[0-9])(?=.</em>[a-z])|(?=.<em>[0-9])(?=.</em>[A-Z])|(?=.<em>[a-z])(?=.</em>[A-Z]))^[0-9A-Za-z]{6,12}$/;<br>console.log( reg.test(“1234567”) ); // false 全是数字<br>console.log( reg.test(“abcdef”) ); // false 全是小写字母<br>console.log( reg.test(“ABCDEFGH”) ); // false 全是大写字母<br>console.log( reg.test(“ab23C”) ); // false 不足6位<br>console.log( reg.test(“ABCDEF234”) ); // true 大写字母和数字</p>
<h2 id="console-log-reg-test-“abcdEF234”-true-三者都有"><a href="#console-log-reg-test-“abcdEF234”-true-三者都有" class="headerlink" title="console.log( reg.test(“abcdEF234”) ); // true 三者都有"></a>console.log( reg.test(“abcdEF234”) ); // true 三者都有</h2><p>理解：<br>上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。<br>/(?=.<em>[0-9])^[0-9A-Za-z]{6,12}$/<br>对于这个正则，我们只需要弄明白(?=.</em>[0-9])^即可。<br>分开来看就是(?=.<em>[0-9])和^。<br>表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。<br>(?=.</em>[0-9])表示该位置后面的字符匹配.*[0-9]，即，有任何多个任意字符，后面再跟个数字。<br>翻译成大白话，就是接下来的字符，必须包含个数字。</p>
<p>另外一种解法<br>“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。<br>那么要求“不能全部都是数字”，怎么做呢？(?!p)出马！<br>对应的正则是：<br>var reg = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/;</p>
<h2 id="优化后的正则为："><a href="#优化后的正则为：" class="headerlink" title="优化后的正则为："></a>优化后的正则为：</h2><p>var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;<br>console.log( reg.test(“1234567”) ); // false 全是数字<br>console.log( reg.test(“abcdef”) ); // false 全是小写字母<br>console.log( reg.test(“ABCDEFGH”) ); // false 全是大写字母<br>console.log( reg.test(“ab23C”) ); // false 不足6位<br>console.log( reg.test(“ABCDEF234”) ); // true 大写字母和数字</p>
<h2 id="console-log-reg-test-“abcdEF234”-true-三者都有-1"><a href="#console-log-reg-test-“abcdEF234”-true-三者都有-1" class="headerlink" title="console.log( reg.test(“abcdEF234”) ); // true 三者都有"></a>console.log( reg.test(“abcdEF234”) ); // true 三者都有</h2><h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><p>不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。<br>对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。<br>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。<br>引用某个分组，会有两种情形：在JavaScript里引用它，在正则表达式里引用它。<br>本章内容虽相对简单，但我也要写长点。</p>
<pre><code>内容包括：
1.分组和分支结构
2.捕获分组
3.反向引用
4.非捕获分组
5.相关案例
</code></pre><ol>
<li>分组和分支结</li>
</ol>
<p>1.1 分组<br>我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。</p>
<h2 id="其中括号是提供分组功能，使量词-作用于“ab”这个整体，测试如下："><a href="#其中括号是提供分组功能，使量词-作用于“ab”这个整体，测试如下：" class="headerlink" title="其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下："></a>其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下：</h2><p>var regex = /(ab)+/g;<br>var string = “ababa abbb ababab”;<br>console.log( string.match(regex) );</p>
<h2 id="gt-“abab”-“ab”-“ababab”"><a href="#gt-“abab”-“ab”-“ababab”" class="headerlink" title="// =&gt; [“abab”, “ab”, “ababab”]"></a>// =&gt; [“abab”, “ab”, “ababab”]</h2><p>1.2 分支结构<br>在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能。<br>比如，要匹配如下的字符串：<br>I love JavaScript<br>I love Regular Expression</p>
<h2 id="可以使用正则："><a href="#可以使用正则：" class="headerlink" title="可以使用正则："></a>可以使用正则：</h2><p>var regex = /^I love (JavaScript|Regular Expression)$/;<br>console.log( regex.test(“I love JavaScript”) );<br>console.log( regex.test(“I love Regular Expression”) );<br>// =&gt; true</p>
<h2 id="gt-true-5"><a href="#gt-true-5" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><ol start="2">
<li>引用分组<br>这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。<br>而要使用它带来的好处，必须配合使用实现环境的API。<br>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：</li>
</ol>
<hr>
<h2 id="var-regex-d-4-d-2-d-2"><a href="#var-regex-d-4-d-2-d-2" class="headerlink" title="var regex = /\d{4}-\d{2}-\d{2}/;"></a>var regex = /\d{4}-\d{2}-\d{2}/;</h2><p>然后再修改成括号版的：</p>
<hr>
<h2 id="var-regex-d-4-d-2-d-2-1"><a href="#var-regex-d-4-d-2-d-2-1" class="headerlink" title="var regex = /(\d{4})-(\d{2})-(\d{2})/;"></a>var regex = /(\d{4})-(\d{2})-(\d{2})/;</h2><p>为什么要使用这个正则呢？</p>
<p>2.1 提取数据</p>
<h2 id="比如提取出年、月、日，可以这么做："><a href="#比如提取出年、月、日，可以这么做：" class="headerlink" title="比如提取出年、月、日，可以这么做："></a>比如提取出年、月、日，可以这么做：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( string.match(regex) );</p>
<h2 id="gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”"><a href="#gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”" class="headerlink" title="// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]</h2><h2 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h2><p>var regex = /\d{4}-\d{2}-\d{2}/;<br>var string = “2017-06-12”;<br>console.log( string.match(regex) );</p>
<h2 id="gt-“2017-06-12”-index-0-input-“2017-06-12”"><a href="#gt-“2017-06-12”-index-0-input-“2017-06-12”" class="headerlink" title="// =&gt; [“2017-06-12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, index: 0, input: “2017-06-12”]</h2><p>match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）。</p>
<h2 id="另外也可以使用正则对象的exec方法："><a href="#另外也可以使用正则对象的exec方法：" class="headerlink" title="另外也可以使用正则对象的exec方法："></a>另外也可以使用正则对象的exec方法：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( regex.exec(string) );</p>
<h2 id="gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”-1"><a href="#gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”-1" class="headerlink" title="// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]</h2><h2 id="同时，也可以使用构造函数的全局属性-1至-9来获取："><a href="#同时，也可以使用构造函数的全局属性-1至-9来获取：" class="headerlink" title="同时，也可以使用构造函数的全局属性$1至$9来获取："></a>同时，也可以使用构造函数的全局属性$1至$9来获取：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;</p>
<p>regex.test(string); // 正则操作即可，例如<br>//regex.exec(string);<br>//string.match(regex);</p>
<p>console.log(RegExp.$1); // “2017”<br>console.log(RegExp.$2); // “06”</p>
<h2 id="console-log-RegExp-3-“12”"><a href="#console-log-RegExp-3-“12”" class="headerlink" title="console.log(RegExp.$3); // “12”"></a>console.log(RegExp.$3); // “12”</h2><p>2.2 替换</p>
<h2 id="比如，想把yyyy-mm-dd格式，替换成mm-dd-yyyy怎么做？"><a href="#比如，想把yyyy-mm-dd格式，替换成mm-dd-yyyy怎么做？" class="headerlink" title="比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？"></a>比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, “$2/$3/$1”);<br>console.log(result);</p>
<h2 id="gt-“06-12-2017”"><a href="#gt-“06-12-2017”" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><h2 id="其中replace中的，第二个参数里用-1、-2、-3指代相应的分组。等价于如下的形式："><a href="#其中replace中的，第二个参数里用-1、-2、-3指代相应的分组。等价于如下的形式：" class="headerlink" title="其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式："></a>其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, function() {<br>    return RegExp.$2 + “/“ + RegExp.$3 + “/“ + RegExp.$1;<br>});<br>console.log(result);</p>
<h2 id="gt-“06-12-2017”-1"><a href="#gt-“06-12-2017”-1" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><h2 id="也等价于："><a href="#也等价于：" class="headerlink" title="也等价于："></a>也等价于：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, function(match, year, month, day) {<br>    return month + “/“ + day + “/“ + year;<br>});<br>console.log(result);</p>
<h2 id="gt-“06-12-2017”-2"><a href="#gt-“06-12-2017”-2" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><ol start="3">
<li>反向引用<br>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。<br>还是以日期为例。<br>比如要写一个正则支持匹配如下三种格式：<br>2016-06-12<br>2016/06/12<br>2016.06.12<br>最先可能想到的正则是:</li>
</ol>
<hr>
<p>var regex = /\d{4}(-|\/|.)\d{2}(-|\/|.)\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true</p>
<h2 id="console-log-regex-test-string4-true"><a href="#console-log-regex-test-string4-true" class="headerlink" title="console.log( regex.test(string4) ); // true"></a>console.log( regex.test(string4) ); // true</h2><p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配”2016-06/12”这样的数据。</p>
<h2 id="假设我们想要求分割符前后一致怎么办？此时需要使用反向引用："><a href="#假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：" class="headerlink" title="假设我们想要求分割符前后一致怎么办？此时需要使用反向引用："></a>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：</h2><p>var regex = /\d{4}(-|\/|.)\d{2}\1\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true</p>
<h2 id="console-log-regex-test-string4-false"><a href="#console-log-regex-test-string4-false" class="headerlink" title="console.log( regex.test(string4) ); // false"></a>console.log( regex.test(string4) ); // false</h2><p>注意里面的\1，表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。<br>我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组。<br>看到这里，此时，恐怕你会有三个问题。</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://https://liejiayong.github.io/chovitaminljy/2018/04/05/regular Expression/" data-id="cjiypfxnd0001g41l36yfc5am" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    <nav id="article-nav">
  
    <a href="/2018/04/05/计算今天为周几/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算当天为星期几
        
      </div>
    </a>
  
  
    <a href="/2018/03/21/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>
  
</article></section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>
  
    <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/05/计算今天为周几/">计算当天为星期几</a>
          </li>
        
          <li>
            <a href="/2018/04/05/regular Expression/">正则表达式总结</a>
          </li>
        
          <li>
            <a href="/2018/03/21/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 chovitaminljy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
