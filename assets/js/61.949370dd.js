(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{672:function(e,r,t){"use strict";t.r(r);var a=t(9),n=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("持续更新...")])]),e._v(" "),t("ul",[t("li",[e._v("Browser： 对应一个浏览器实例，一个 Browser 可以包含多个 BrowserContext")]),e._v(" "),t("li",[e._v("BrowserContext： 对应浏览器一个上下文会话，就像我们打开一个普通的 Chrome 之后又打开一个隐身模式的浏览器一样，BrowserContext 具有独立的 Session(cookie 和 cache 独立不共享)，一个 BrowserContext 可以包含多个 Page")]),e._v(" "),t("li",[e._v("Page：表示一个 Tab 页面，通过 browserContext.newPage()/browser.newPage() 创建，browser.newPage() 创建页面时会使用默认的 BrowserContext，一个 Page 可以包含多个 Frame")]),e._v(" "),t("li",[e._v("Frame: 一个框架，每个页面有一个主框架（page.MainFrame()）,也可以多个子框架，主要由 iframe 标签创建产生的")]),e._v(" "),t("li",[e._v("ExecutionContext： 是 javascript 的执行环境，每一个 Frame 都一个默认的 javascript 执行环境")]),e._v(" "),t("li",[e._v("ElementHandle: 对应 DOM 的一个元素节点，通过该该实例可以实现对元素的点击，填写表单等行为，我们可以通过选择器，xPath 等来获取对应的元素")]),e._v(" "),t("li",[e._v("JsHandle：对应 DOM 中的 javascript 对象，ElementHandle 继承于 JsHandle，由于我们无法直接操作 DOM 中对象，所以封装成 JsHandle 来实现相关功能")]),e._v(" "),t("li",[e._v("CDPSession：可以直接与原生的 CDP 进行通信，通过 session.send 函数直接发消息，通过 session.on 接收消息，可以实现 Puppeteer API 中没有涉及的功能")]),e._v(" "),t("li",[e._v("Coverage：获取 JavaScript 和 CSS 代码覆盖率")]),e._v(" "),t("li",[e._v("Tracing：抓取性能数据进行分析")]),e._v(" "),t("li",[e._v("Response： 页面收到的响应")]),e._v(" "),t("li",[e._v("Request： 页面发出的请求")])]),e._v(" "),t("h1",{attrs:{id:"相关文献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关文献"}},[e._v("#")]),e._v(" 相关文献")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://www.puppeteerjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Puppeteer 官方文档"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=n.exports}}]);