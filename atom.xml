<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chovitaminljy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://https://liejiayong.github.io/chovitaminljy/"/>
  <updated>2018-06-28T15:27:48.647Z</updated>
  <id>http://https://liejiayong.github.io/chovitaminljy/</id>
  
  <author>
    <name>chovitaminljy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算当天为星期几</title>
    <link href="http://https://liejiayong.github.io/chovitaminljy/2018/04/05/%E8%AE%A1%E7%AE%97%E4%BB%8A%E5%A4%A9%E4%B8%BA%E5%91%A8%E5%87%A0/"/>
    <id>http://https://liejiayong.github.io/chovitaminljy/2018/04/05/计算今天为周几/</id>
    <published>2018-04-05T13:38:13.680Z</published>
    <updated>2018-06-28T15:27:48.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想知道某个日期是星期几时，不一定要打开日历才能找出来。只要学会以下这个方程式，任何日期都可以算出是星期几。</p></blockquote><h2 id="首先，让我们先看看以下这三个表格里面的代码。"><a href="#首先，让我们先看看以下这三个表格里面的代码。" class="headerlink" title="首先，让我们先看看以下这三个表格里面的代码。"></a>首先，让我们先看看以下这三个表格里面的代码。</h2><p>|   星期      |   代码      |<br>|   星期日    |    0        |<br>|   星期一    |    1        |<br>|   星期二    |    2        |<br>|   星期三    |    3        |<br>|   星期四    |    4        |<br>|   星期五    |    5        |</p><h2 id="星期六-6"><a href="#星期六-6" class="headerlink" title="|   星期六    |    6        |"></a>|   星期六    |    6        |</h2><hr><p>|   月份      |   代码      |<br>|   一月      |    6        |<br>|   二月      |    2        |<br>|   三月      |    2        |<br>|   四月      |    5        |<br>|   五月      |    0        |<br>|   六月      |    3        |<br>|   七月      |    5        |<br>|   八月      |    1        |<br>|   九月      |    4        |<br>|   十月      |    6        |<br>|   十一月    |    2        |</p><h2 id="十二月-4"><a href="#十二月-4" class="headerlink" title="|   十二月    |    4        |"></a>|   十二月    |    4        |</h2><hr><p>|   闰年      |   代码       |<br>|   2000      |    0         |<br>|   2004      |    5         |<br>|   2008      |    10        |<br>|   2012      |    15        |<br>|   2016      |    20        |<br>|   2020      |    25        |</p><h2 id="2024-30"><a href="#2024-30" class="headerlink" title="|   2024      |    30        |"></a>|   2024      |    30        |</h2><p>首先，星期日到星期六分别用0-6来表示，而年份的话以2000年为基年，每加一年则+1（例：2001年的代码为0+1=1），而到了闰年则再+1（例：2004年的代码为0+4+1=5；计算2008年的代码则是用2004的代码5+4+1=10）以此类推。在这里比较困难的只是月份的代码，这里必须背的，将这些代码牢牢地记在脑海里。</p><p>第二点要记住的就是，因为一个礼拜有7天，凡是7的倍数都可以被拿掉。例如2008年的代码是10，拿掉7则剩下3；2024年的代码是30，拿掉7x4=28则剩下30-28=2。</p><h2 id="▼以下图为例，我们这次要计算2069年7月20号是星期几。"><a href="#▼以下图为例，我们这次要计算2069年7月20号是星期几。" class="headerlink" title="▼以下图为例，我们这次要计算2069年7月20号是星期几。"></a>▼以下图为例，我们这次要计算2069年7月20号是星期几。</h2><p>7-20-2069<br>5 + 6 + 2 = 13<br>            -7<br>            ___<br>             6</p><pre><code>星期六</code></pre><hr><p>为了算出2069年的代码，我们将69拆分成68+1。因为68是闰年，我们除以4可以得出2068是2000年后的第17个闰年。以17乘5我们得出85，再加上1我们可以得出2069年的代码为86。</p><p>（简地来说就是69=68+1=（4x17）+1。因为闰年要+1，所以变成[（4+1）x17]+1=86。）</p><p>接下来，因为7的倍数可以被拿掉，所以86除以7我们得出余数为2；相同地，20除以7的余数是6。然后根据上面的表格我们知道7月的代码是5。</p><p>要计算出某个日期是星期几，我们只需要将年份的代码+月份的代码+日期就可以算出了！首先我们用5+6+2=13，拿掉7后我们最终得出6这个数字。也就是说2069年7月20号是星期六！</p><p>看了以上的例子，相信这些简单的加法应该不会难倒你吧！接下来，我们要提醒大家，如果要计算的日期是闰年的1月或2月的话，此时代码就要-1。为了让大家更能了解，就让我们一起来算一算2004年2月18号是星期几吧。</p><hr><p>2-18-2004<br>2 + 4 + 5 = 11</p><pre><code>-7-----4-1星期三</code></pre><hr><p>以上的算法只适用于2000年到2099年之间的任一日期。如果要算1999年之前或2099年之后的话，只需要再加上以下代码就可以算出正确的答案了。</p><hr><p>|   年份            |   代码       |<br>|   2300到2399      |    +1        |<br>|   2200到2299      |    +3        |<br>|   2100到2199      |    +5        |<br>|   2000到2099      |    0         |<br>|   1900到1999      |    +1        |<br>|   1800到1899      |    +3        |<br>|   1700到1799      |    +5        |<br>|   1600到1699      |    0         |<br>|   1500到1599      |    +1        |<br>|   1400到1499      |    +3        |<br>|   1300到1399      |    +5        |</p><h2 id="1200到1299-0"><a href="#1200到1299-0" class="headerlink" title="|   1200到1299      |    0         |"></a>|   1200到1299      |    0         |</h2><p>这些数学小技巧是不是很神奇呢？尤其是最后一个，只需要加减乘除就可以算出某个日期是星期几。学校里完全没有教过这样的方式，也许大家可以拿去和数学老师讨论一下，说不定会被称赞呢。虽然数学还是有很多必须理解的观念，但多了一些小技巧，至少在计算上会快一点，现实生活中偶尔用到也是很实用的。赶快自己动手算一算，然后把这些学校没教的数学分享出去让大家知道吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;想知道某个日期是星期几时，不一定要打开日历才能找出来。只要学会以下这个方程式，任何日期都可以算出是星期几。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;首先，让我们先看看以下这三个表格里面的代码。&quot;&gt;&lt;a href=&quot;#首先，让我们先看看以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式总结</title>
    <link href="http://https://liejiayong.github.io/chovitaminljy/2018/04/05/regular%20Expression/"/>
    <id>http://https://liejiayong.github.io/chovitaminljy/2018/04/05/regular Expression/</id>
    <published>2018-04-05T13:38:13.641Z</published>
    <updated>2018-06-28T15:29:37.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置</p></blockquote><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><pre><code>内容包括：1.两种模糊匹配2.字符组3.量词4.分支结构5.案例分析</code></pre><p>1 两种模糊匹配</p><p>1.1 横向模糊匹配</p><blockquote><p>一个正则可匹配的字符串的长度不是固定的，可以是多种情况的<br>var regex = /ab{2,5}c/g<br>var string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;<br>console.log( string.match(regex) );<br>// =&gt; [“abbc”, “abbbc”, “abbbbc”, “abbbbbc”]</p></blockquote><p>1.2 纵向模糊匹配</p><blockquote><p>一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p></blockquote><hr><p>var regex = /a[123]b/g;<br>var string = “a0b a1b a2b a3b a4b”;<br>console.log( string.match(regex) );</p><h2 id="gt-“a1b”-“a2b”-“a3b”"><a href="#gt-“a1b”-“a2b”-“a3b”" class="headerlink" title="// =&gt; [“a1b”, “a2b”, “a3b”]"></a>// =&gt; [“a1b”, “a2b”, “a3b”]</h2><ol start="2"><li>字符组 []<br>2.1 范围表示法<br>匹配“a”、“-”、“z”这三者中任意一个字符<br>[-az]或[az-]或[a-z]</li></ol><p>2.2 排除字符组<br>字符组的第一位放^（脱字符），表示求反的概念<br>[^abc]，表示是一个除”a”、”b”、”c”之外的任意一个字符</p><p>2.3 常见的简写形式<br>    \d   就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。<br>    \D   就是[^0-9]。表示除数字外的任意字符。<br>    \w   就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。<br>    \W   是[^0-9a-zA-Z_]。非单词字符。<br>    \s   是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。<br>    \S  是[^ \t\v\n\r\f]。 非空白符。<br>    .    就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。</p><h1 id="字符组总结："><a href="#字符组总结：" class="headerlink" title="字符组总结："></a>字符组总结：</h1><pre><code>[\d\D]、[\w\W]、[\s\S]和[^]都可以实现匹配任意字符</code></pre><ol start="3"><li>量词</li></ol><p>量词也称重复。掌握{m,n}的准确含义后，只需要记住一些简写形式。</p><p>3.1 简写形式<br>    {m,}     表示至少出现m次。<br>    {m}      等价于{m,m}，表示出现m次。<br>    ?        等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</p><pre><code>+        等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。*        等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</code></pre><p>3.2 贪婪匹配和惰性匹配<br>    例子：</p><pre><code>贪婪-&gt;它会尽可能多的匹配 (只要在能力范围内，越多越好)</code></pre><hr><pre><code>var regex = /\d{2,5}/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) );// =&gt; [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;]</code></pre><hr><pre><code>惰性-&gt;尽可能少的匹配</code></pre><hr><pre><code>var regex = /\d{2,5}?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) );// =&gt; [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;]</code></pre><hr><pre><code>惰性匹配总结：    1.通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：    {m,n}?    {m,}?    ??    +?    *?    2.对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？    3.分支也属于惰性</code></pre><ol start="4"><li><p>多选分支</p><blockquote><p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。<br> 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一</p></blockquote><p>  例如要匹配”good”和”nice”可以使用/good|nice/。测试如下：</p></li></ol><hr><pre><code>var regex = /good|nice/g;var string = &quot;good idea, nice try.&quot;;console.log( string.match(regex) );// =&gt; [&quot;good&quot;, &quot;nice&quot;]</code></pre><hr><pre><code>但有个事实我们应该注意，比如我用/good|goodbye/，去匹配&quot;goodbye&quot;字符串时，结果是&quot;good&quot;：</code></pre><hr><pre><code>var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;good&quot;]</code></pre><hr><pre><code>而把正则改成/goodbye|good/，结果是：</code></pre><hr><pre><code>var regex = /goodbye|good/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) );// =&gt; [&quot;goodbye&quot;]</code></pre><hr><p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。<br>下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）：</p><ol start="5"><li>案例分析<blockquote><p>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。</p></blockquote></li></ol><p>5.1 匹配16进制颜色值<br>要求匹配：</p><p>#ffbbad</p><p>#Fc01DF</p><p>#FFF</p><h2 id="ffE"><a href="#ffE" class="headerlink" title="#ffE"></a>#ffE</h2><p>var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;<br>var string = “#ffbbad #Fc01DF #FFF #ffE”;<br>console.log( string.match(regex) );</p><h2 id="gt-“-ffbbad”-“-Fc01DF”-“-FFF”-“-ffE”"><a href="#gt-“-ffbbad”-“-Fc01DF”-“-FFF”-“-ffE”" class="headerlink" title="// =&gt; [“#ffbbad”, “#Fc01DF”, “#FFF”, “#ffE”]"></a>// =&gt; [“#ffbbad”, “#Fc01DF”, “#FFF”, “#ffE”]</h2><p>5.2 匹配时间<br>以24小时制为例。<br>要求匹配：<br>23:59</p><h2 id="02-07"><a href="#02-07" class="headerlink" title="02:07"></a>02:07</h2><p>var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;<br>console.log( regex.test(“23:59”) );<br>console.log( regex.test(“02:07”) );<br>// =&gt; true</p><h2 id="gt-true"><a href="#gt-true" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.3 匹配日期<br>比如yyyy-mm-dd格式为例。<br>要求匹配：</p><h2 id="2017-10-13"><a href="#2017-10-13" class="headerlink" title="2017-10-13"></a>2017-10-13</h2><p>var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;<br>console.log( regex.test(“2017-06-10”) );</p><h2 id="gt-true-1"><a href="#gt-true-1" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.4 window操作系统文件路径<br>要求匹配：<br>F:\study\javascript\regex\regular expression.pdf<br>F:\study\javascript\regex\<br>F:\study\javascript</p><h2 id="F"><a href="#F" class="headerlink" title="F:\"></a>F:\</h2><p>var regex = /^[a-zA-Z]:\([^\&lt;&gt;|’’?\r\n/]+\)*([^\&lt;&gt;|’’?\r\n/]+)?$/;<br>console.log( regex.test(“F:\study\javascript\regex\regular expression.pdf”) );<br>console.log( regex.test(“F:\study\javascript\regex\“) );<br>console.log( regex.test(“F:\study\javascript”) );<br>console.log( regex.test(“F:\“) );<br>// =&gt; true<br>// =&gt; true<br>// =&gt; true</p><h2 id="gt-true-2"><a href="#gt-true-2" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><p>5.5 匹配id<br>要求从</p><p><div id="container" class="main"></div></p><h2 id="提取出id-”container”"><a href="#提取出id-”container”" class="headerlink" title="提取出id=”container”"></a>提取出id=”container”</h2><p>var regex = /id=”[^”]”/;</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><blockquote><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p></blockquote><pre><code>内容包括：1.什么是位置？2.如何匹配位置？3.位置的特性4.几个应用实例分析</code></pre><ol><li><p>什么是位置呢？<br>位置是相邻字符之间的位置.<br>如：HELLO<br>||||||    这里的一杠所致向的是相邻字符之间的位置.</p></li><li><p>如何匹配位置呢？</p><p> 在ES5中，共有6个锚字符：<br> ^ $ \b \B (?=p) (?!p)</p></li></ol><p>2.1 ^和$<br>    ^（脱字符）匹配开头，在多行匹配中匹配行开头。<br>    $（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p><h2 id="比如我们把字符串的开头和结尾用”-”替换（位置可以替换成字符的！）"><a href="#比如我们把字符串的开头和结尾用”-”替换（位置可以替换成字符的！）" class="headerlink" title="比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）"></a>比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）</h2><p>var regex = \^|$\g<br>var result = “hello”.replace(regex,”#”);<br>console.log(result);</p><h2 id="gt-“-hello-”"><a href="#gt-“-hello-”" class="headerlink" title="// =&gt; “#hello#”"></a>// =&gt; “#hello#”</h2><h2 id="多行匹配模式时，二者是行的概念，这个需要我们的注意："><a href="#多行匹配模式时，二者是行的概念，这个需要我们的注意：" class="headerlink" title="多行匹配模式时，二者是行的概念，这个需要我们的注意："></a>多行匹配模式时，二者是行的概念，这个需要我们的注意：</h2><p>var result = “I\nlove\njavascript”.replace(/^|$/gm, ‘#’);<br>console.log(result);<br>/*</p><p>#I#</p><p>#love#</p><p>#javascript#</p><h2 id=""><a href="#" class="headerlink" title="*/"></a>*/</h2><p>2.2 \b和\B<br>    \b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。</p><pre><code>比如一个文件名是&quot;[JS] Lesson_01.mp4&quot;中的\b，如下：</code></pre><hr><p>var result = “[JS] Lesson_01.mp4”.replace(/\b/g, ‘#’);<br>console.log(result);</p><h2 id="gt-“-JS-Lesson-01-mp4-”"><a href="#gt-“-JS-Lesson-01-mp4-”" class="headerlink" title="// =&gt; “[#JS#] #Lesson_01#.#mp4#”"></a>// =&gt; “[#JS#] #Lesson_01#.#mp4#”</h2><pre><code>\B就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。比如上面的例子，把所有\B替换成&quot;#&quot;：</code></pre><hr><p>var result = “[JS] Lesson_01.mp4”.replace(/\B/g, ‘#’);<br>console.log(result);</p><h2 id="gt-“-J-S-L-e-s-s-o-n-0-1-m-p-4”"><a href="#gt-“-J-S-L-e-s-s-o-n-0-1-m-p-4”" class="headerlink" title="// =&gt; “#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4”"></a>// =&gt; “#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4”</h2><pre><code>\b和\B总结：\b -&gt; 不连续单词边界\B -&gt;</code></pre><p>2.3 (?=p)和(?!p)<br>    (?=p)，其中p是一个子模式，即p前面的位置。</p><h2 id="比如-l-，表示’l’字符前面的位置，例如："><a href="#比如-l-，表示’l’字符前面的位置，例如：" class="headerlink" title="比如(?=l)，表示’l’字符前面的位置，例如："></a>比如(?=l)，表示’l’字符前面的位置，例如：</h2><p>var result = “hello”.replace(/(?=l)/g, ‘#’);<br>console.log(result);</p><h2 id="gt-“he-l-lo”"><a href="#gt-“he-l-lo”" class="headerlink" title="// =&gt; “he#l#lo”"></a>// =&gt; “he#l#lo”</h2><h2 id="而-p-就是-p-的反面意思，比如："><a href="#而-p-就是-p-的反面意思，比如：" class="headerlink" title="而(?!p)就是(?=p)的反面意思，比如："></a>而(?!p)就是(?=p)的反面意思，比如：</h2><p>var result = “hello”.replace(/(?!l)/g, ‘#’);<br>console.log(result);</p><h2 id="gt-“-h-ell-o-”"><a href="#gt-“-h-ell-o-”" class="headerlink" title="// =&gt; “#h#ell#o#”"></a>// =&gt; “#h#ell#o#”</h2><pre><code>(?=p)和(?!p)总结：-----------------------------------------------------------|     分类依据     |      (?=p)         |    (?!p)-----------------------------------------------------------|     学名         | positive lookahead | negative lookahead-----------------------------------------------------------|     中文翻译     |  正向先行断言      |  负向先行断言-----------------------------------------------------------|     环视         |  看看右边          |  看看左边-----------------------------------------------------------|     (?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符|     而在本人看来(?=p)就与^一样好理解，就是p前面的那个位置-----------------------------------------------------------</code></pre><ol start="3"><li><p>位置的特性</p><blockquote><p>对于位置的理解，我们可以理解成空字符””</p></blockquote><p> 比如”hello”字符串等价于如下的形式：<br> “hello” == “” + “h” + “” + “e” + “” + “l” + “” + “l” + “o” + “”;<br> 也等价于：<br> “hello” == “” + “” + “hello”</p></li></ol><h2 id="因此，把-hello-写成-hello-，是没有任何问题的："><a href="#因此，把-hello-写成-hello-，是没有任何问题的：" class="headerlink" title="因此，把/^hello$/写成/^^hello$$$/，是没有任何问题的："></a>因此，把/^hello$/写成/^^hello$$$/，是没有任何问题的：</h2><p>var result = /^^hello$$$/.test(“hello”);<br>console.log(result);</p><h2 id="gt-true-3"><a href="#gt-true-3" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><h2 id="甚至可以写成更复杂的"><a href="#甚至可以写成更复杂的" class="headerlink" title="甚至可以写成更复杂的:"></a>甚至可以写成更复杂的:</h2><p>var result = /(?=he)^^he(?=\w)llo$\b\b$/.test(“hello”);<br>console.log(result);</p><h2 id="gt-true-4"><a href="#gt-true-4" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><ol start="4"><li>相关案例</li></ol><h2 id="4-1-不匹配任何东西的正则"><a href="#4-1-不匹配任何东西的正则" class="headerlink" title="4.1 不匹配任何东西的正则"></a>4.1 不匹配任何东西的正则</h2><p>.^\</p><h2 id="因为此正则要求只有一个字符，但该字符后面是开头。"><a href="#因为此正则要求只有一个字符，但该字符后面是开头。" class="headerlink" title="因为此正则要求只有一个字符，但该字符后面是开头。"></a>因为此正则要求只有一个字符，但该字符后面是开头。</h2><p>4.2 数字的千位分隔符表示法<br>比如把”12345678”，变成”12,345,678”。<br>可见是需要把相应的位置替换成”,”。</p><h2 id="4-2-1-弄出最后一个逗号"><a href="#4-2-1-弄出最后一个逗号" class="headerlink" title="4.2.1 弄出最后一个逗号"></a>4.2.1 弄出最后一个逗号</h2><p>var result = “12345678”.replace(/(?=\d{3}$)/g, ‘,’)<br>console.log(result);</p><h2 id="gt-“12345-678”"><a href="#gt-“12345-678”" class="headerlink" title="// =&gt; “12345,678”"></a>// =&gt; “12345,678”</h2><h2 id="4-2-2-弄出所有的逗号"><a href="#4-2-2-弄出所有的逗号" class="headerlink" title="4.2.2 弄出所有的逗号"></a>4.2.2 弄出所有的逗号</h2><p>var result = “123456789”.replace(/(?=(\d{3})+$)/g, ‘,’)<br>console.log(result);</p><h2 id="gt-“-123-456-789”"><a href="#gt-“-123-456-789”" class="headerlink" title="// =&gt; “,123,456,789”"></a>// =&gt; “,123,456,789”</h2><p>因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。<br>怎么解决呢？我们要求匹配的到这个位置不能是开头。<br>我们知道匹配开头可以使用^，但要求这个位置不是开头怎么办？</p><hr><p>var string1 = “12345678”,<br>string2 = “123456789”;<br>var reg = /(?!^)(?=(\d{3})+$)/g;</p><p>var result = string1.replace(reg, ‘,’)<br>console.log(result);<br>// =&gt; “12,345,678”</p><p>result = string2.replace(reg, ‘,’);<br>console.log(result);</p><h2 id="gt-“123-456-789”"><a href="#gt-“123-456-789”" class="headerlink" title="// =&gt; “123,456,789”"></a>// =&gt; “123,456,789”</h2><p>4.2.4 支持其他形式<br>如果要把”12345678 123456789”替换成”12,345,678 123,456,789”。</p><h2 id="此时我们需要修改正则，把里面的开头-和结尾-，替换成-b："><a href="#此时我们需要修改正则，把里面的开头-和结尾-，替换成-b：" class="headerlink" title="此时我们需要修改正则，把里面的开头^和结尾$，替换成\b："></a>此时我们需要修改正则，把里面的开头^和结尾$，替换成\b：</h2><p>var string = “12345678 123456789”,<br>reg = /(?!\b)(?=(\d{3})+\b)/g;    或/\B(?=(\d{3})+\b)/g<br>var result = string.replace(reg, ‘,’)<br>console.log(result);</p><h2 id="gt-“12-345-678-123-456-789”"><a href="#gt-“12-345-678-123-456-789”" class="headerlink" title="// =&gt; “12,345,678 123,456,789”"></a>// =&gt; “12,345,678 123,456,789”</h2><p>4.3 验证密码问题<br>1.同时包含数字和小写字母<br>2.同时包含数字和大写字母<br>3.同时包含小写字母和大写字母<br>4.同时包含数字、小写字母和大写字母</p><h2 id="以上的4种情况是或的关系（实际上，可以不用第4条）。"><a href="#以上的4种情况是或的关系（实际上，可以不用第4条）。" class="headerlink" title="以上的4种情况是或的关系（实际上，可以不用第4条）。"></a>以上的4种情况是或的关系（实际上，可以不用第4条）。</h2><p>var reg = /((?=.<em>[0-9])(?=.</em>[a-z])|(?=.<em>[0-9])(?=.</em>[A-Z])|(?=.<em>[a-z])(?=.</em>[A-Z]))^[0-9A-Za-z]{6,12}$/;<br>console.log( reg.test(“1234567”) ); // false 全是数字<br>console.log( reg.test(“abcdef”) ); // false 全是小写字母<br>console.log( reg.test(“ABCDEFGH”) ); // false 全是大写字母<br>console.log( reg.test(“ab23C”) ); // false 不足6位<br>console.log( reg.test(“ABCDEF234”) ); // true 大写字母和数字</p><h2 id="console-log-reg-test-“abcdEF234”-true-三者都有"><a href="#console-log-reg-test-“abcdEF234”-true-三者都有" class="headerlink" title="console.log( reg.test(“abcdEF234”) ); // true 三者都有"></a>console.log( reg.test(“abcdEF234”) ); // true 三者都有</h2><p>理解：<br>上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。<br>/(?=.<em>[0-9])^[0-9A-Za-z]{6,12}$/<br>对于这个正则，我们只需要弄明白(?=.</em>[0-9])^即可。<br>分开来看就是(?=.<em>[0-9])和^。<br>表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。<br>(?=.</em>[0-9])表示该位置后面的字符匹配.*[0-9]，即，有任何多个任意字符，后面再跟个数字。<br>翻译成大白话，就是接下来的字符，必须包含个数字。</p><p>另外一种解法<br>“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。<br>那么要求“不能全部都是数字”，怎么做呢？(?!p)出马！<br>对应的正则是：<br>var reg = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/;</p><h2 id="优化后的正则为："><a href="#优化后的正则为：" class="headerlink" title="优化后的正则为："></a>优化后的正则为：</h2><p>var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;<br>console.log( reg.test(“1234567”) ); // false 全是数字<br>console.log( reg.test(“abcdef”) ); // false 全是小写字母<br>console.log( reg.test(“ABCDEFGH”) ); // false 全是大写字母<br>console.log( reg.test(“ab23C”) ); // false 不足6位<br>console.log( reg.test(“ABCDEF234”) ); // true 大写字母和数字</p><h2 id="console-log-reg-test-“abcdEF234”-true-三者都有-1"><a href="#console-log-reg-test-“abcdEF234”-true-三者都有-1" class="headerlink" title="console.log( reg.test(“abcdEF234”) ); // true 三者都有"></a>console.log( reg.test(“abcdEF234”) ); // true 三者都有</h2><h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><p>不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。<br>对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。<br>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。<br>引用某个分组，会有两种情形：在JavaScript里引用它，在正则表达式里引用它。<br>本章内容虽相对简单，但我也要写长点。</p><pre><code>内容包括：1.分组和分支结构2.捕获分组3.反向引用4.非捕获分组5.相关案例</code></pre><ol><li>分组和分支结</li></ol><p>1.1 分组<br>我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。</p><h2 id="其中括号是提供分组功能，使量词-作用于“ab”这个整体，测试如下："><a href="#其中括号是提供分组功能，使量词-作用于“ab”这个整体，测试如下：" class="headerlink" title="其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下："></a>其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下：</h2><p>var regex = /(ab)+/g;<br>var string = “ababa abbb ababab”;<br>console.log( string.match(regex) );</p><h2 id="gt-“abab”-“ab”-“ababab”"><a href="#gt-“abab”-“ab”-“ababab”" class="headerlink" title="// =&gt; [“abab”, “ab”, “ababab”]"></a>// =&gt; [“abab”, “ab”, “ababab”]</h2><p>1.2 分支结构<br>在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能。<br>比如，要匹配如下的字符串：<br>I love JavaScript<br>I love Regular Expression</p><h2 id="可以使用正则："><a href="#可以使用正则：" class="headerlink" title="可以使用正则："></a>可以使用正则：</h2><p>var regex = /^I love (JavaScript|Regular Expression)$/;<br>console.log( regex.test(“I love JavaScript”) );<br>console.log( regex.test(“I love Regular Expression”) );<br>// =&gt; true</p><h2 id="gt-true-5"><a href="#gt-true-5" class="headerlink" title="// =&gt; true"></a>// =&gt; true</h2><ol start="2"><li>引用分组<br>这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。<br>而要使用它带来的好处，必须配合使用实现环境的API。<br>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：</li></ol><hr><h2 id="var-regex-d-4-d-2-d-2"><a href="#var-regex-d-4-d-2-d-2" class="headerlink" title="var regex = /\d{4}-\d{2}-\d{2}/;"></a>var regex = /\d{4}-\d{2}-\d{2}/;</h2><p>然后再修改成括号版的：</p><hr><h2 id="var-regex-d-4-d-2-d-2-1"><a href="#var-regex-d-4-d-2-d-2-1" class="headerlink" title="var regex = /(\d{4})-(\d{2})-(\d{2})/;"></a>var regex = /(\d{4})-(\d{2})-(\d{2})/;</h2><p>为什么要使用这个正则呢？</p><p>2.1 提取数据</p><h2 id="比如提取出年、月、日，可以这么做："><a href="#比如提取出年、月、日，可以这么做：" class="headerlink" title="比如提取出年、月、日，可以这么做："></a>比如提取出年、月、日，可以这么做：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( string.match(regex) );</p><h2 id="gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”"><a href="#gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”" class="headerlink" title="// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]</h2><h2 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h2><p>var regex = /\d{4}-\d{2}-\d{2}/;<br>var string = “2017-06-12”;<br>console.log( string.match(regex) );</p><h2 id="gt-“2017-06-12”-index-0-input-“2017-06-12”"><a href="#gt-“2017-06-12”-index-0-input-“2017-06-12”" class="headerlink" title="// =&gt; [“2017-06-12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, index: 0, input: “2017-06-12”]</h2><p>match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）。</p><h2 id="另外也可以使用正则对象的exec方法："><a href="#另外也可以使用正则对象的exec方法：" class="headerlink" title="另外也可以使用正则对象的exec方法："></a>另外也可以使用正则对象的exec方法：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( regex.exec(string) );</p><h2 id="gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”-1"><a href="#gt-“2017-06-12”-“2017”-“06”-“12”-index-0-input-“2017-06-12”-1" class="headerlink" title="// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]"></a>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]</h2><h2 id="同时，也可以使用构造函数的全局属性-1至-9来获取："><a href="#同时，也可以使用构造函数的全局属性-1至-9来获取：" class="headerlink" title="同时，也可以使用构造函数的全局属性$1至$9来获取："></a>同时，也可以使用构造函数的全局属性$1至$9来获取：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;</p><p>regex.test(string); // 正则操作即可，例如<br>//regex.exec(string);<br>//string.match(regex);</p><p>console.log(RegExp.$1); // “2017”<br>console.log(RegExp.$2); // “06”</p><h2 id="console-log-RegExp-3-“12”"><a href="#console-log-RegExp-3-“12”" class="headerlink" title="console.log(RegExp.$3); // “12”"></a>console.log(RegExp.$3); // “12”</h2><p>2.2 替换</p><h2 id="比如，想把yyyy-mm-dd格式，替换成mm-dd-yyyy怎么做？"><a href="#比如，想把yyyy-mm-dd格式，替换成mm-dd-yyyy怎么做？" class="headerlink" title="比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？"></a>比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, “$2/$3/$1”);<br>console.log(result);</p><h2 id="gt-“06-12-2017”"><a href="#gt-“06-12-2017”" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><h2 id="其中replace中的，第二个参数里用-1、-2、-3指代相应的分组。等价于如下的形式："><a href="#其中replace中的，第二个参数里用-1、-2、-3指代相应的分组。等价于如下的形式：" class="headerlink" title="其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式："></a>其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, function() {<br>    return RegExp.$2 + “/“ + RegExp.$3 + “/“ + RegExp.$1;<br>});<br>console.log(result);</p><h2 id="gt-“06-12-2017”-1"><a href="#gt-“06-12-2017”-1" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><h2 id="也等价于："><a href="#也等价于：" class="headerlink" title="也等价于："></a>也等价于：</h2><p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, function(match, year, month, day) {<br>    return month + “/“ + day + “/“ + year;<br>});<br>console.log(result);</p><h2 id="gt-“06-12-2017”-2"><a href="#gt-“06-12-2017”-2" class="headerlink" title="// =&gt; “06/12/2017”"></a>// =&gt; “06/12/2017”</h2><ol start="3"><li>反向引用<br>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。<br>还是以日期为例。<br>比如要写一个正则支持匹配如下三种格式：<br>2016-06-12<br>2016/06/12<br>2016.06.12<br>最先可能想到的正则是:</li></ol><hr><p>var regex = /\d{4}(-|\/|.)\d{2}(-|\/|.)\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true</p><h2 id="console-log-regex-test-string4-true"><a href="#console-log-regex-test-string4-true" class="headerlink" title="console.log( regex.test(string4) ); // true"></a>console.log( regex.test(string4) ); // true</h2><p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配”2016-06/12”这样的数据。</p><h2 id="假设我们想要求分割符前后一致怎么办？此时需要使用反向引用："><a href="#假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：" class="headerlink" title="假设我们想要求分割符前后一致怎么办？此时需要使用反向引用："></a>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：</h2><p>var regex = /\d{4}(-|\/|.)\d{2}\1\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true</p><h2 id="console-log-regex-test-string4-false"><a href="#console-log-regex-test-string4-false" class="headerlink" title="console.log( regex.test(string4) ); // false"></a>console.log( regex.test(string4) ); // false</h2><p>注意里面的\1，表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。<br>我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组。<br>看到这里，此时，恐怕你会有三个问题。</p><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正则表达式是匹配模式，要么匹配字符，要么匹配位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字符匹配&quot;&gt;&lt;a href=&quot;#字符匹配&quot; class=&quot;headerlink&quot; title=&quot;字符匹配&quot;&gt;&lt;/a&gt;字符匹配&lt;/h2&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://https://liejiayong.github.io/chovitaminljy/2018/03/21/hello-world/"/>
    <id>http://https://liejiayong.github.io/chovitaminljy/2018/03/21/hello-world/</id>
    <published>2018-03-21T14:35:17.005Z</published>
    <updated>2018-03-21T14:35:17.005Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
